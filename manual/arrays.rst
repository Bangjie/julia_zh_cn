.. _man-arrays:

********
多维数组
********

数组是一个存在多维网格中的对象集合。通常，数组包含的对象的类型为 ``Any`` 。对大多数计算而言，数组对象一般更具体为 ``Float64`` 或 ``Int32`` 。

因为性能的原因，Julia 不希望把程序写成向量化的形式。

在 Julia 中，通过引用将参数传递给函数。Julia 的库函数不会修改传递给它的输入。程序员写代码时，如果要修改输入，要多留意，最好先把输入复制一份儿。

基础函数
--------

1. ``ndims(A)`` — A 的维度
2. ``size(A,n)`` — A 在某个维度上的长度
3. ``size(A)`` — 返回一个包含 A 的维度的多元组
4. ``eltype(A)`` — A 中元素的类型
5. ``length(A)`` — A 中元素的个数
6. ``nnz(A)`` — A 中非零元素的个数
7. ``stride(A,k)`` — 在维度 k 上，与邻接元素（在内存中）的线性索引距离
8. ``strides(A)`` — 返回多元组，其分量为在每个维度上，与邻接元素（在内存中）线性索引距离

构造和初始化
------------

下列函数中调用的 ``dims...`` 参数，既可以是维度的单多元组，也可以是维度作为可变参数时的一组值。

1.  ``Array(type, dims...)`` — 未初始化的稠密数组
2.  ``cell(dims...)`` — 未初始化的元胞数组（异构数组）
3.  ``zeros(type, dims...)`` — 指定类型的全 0 数组
4.  ``ones(type, dims...)`` — 指定类型的全 1 数组
5.  ``trues(dims...)`` — 全 ``true`` 的 ``Bool`` 数组
6.  ``falses(dims...)`` — 全 ``false`` 的 ``Bool`` 数组
7.  ``reshape(A, dims...)`` — 将数组中的数据按照指定维度排列
8.  ``copy(A)``  — 复制 ``A``
9.  ``deepcopy(A)`` — 复制 ``A`` ，并递归复制其元素
10. ``similar(A, element_type, dims...)`` — 属性与输入数组（稠密、稀疏等）相同的未初始化数组，但指明了元素类型和维度。第二、三参数可省略，省略时默认为 ``A`` 的元素类型和维度
11. ``reinterpret(type, A)`` — 二进制数据与输入数组相同的数组，但指明了元素类型
12. ``rand(dims)`` — 在 [0,1) 上均匀分布的 ``Float64`` 类型的随机数组
13. ``randf(dims)`` — 在 [0,1) 上均匀分布的 ``Float32`` 类型的随机数组
14. ``randn(dims)`` — ``Float64`` 类型的正态分布随机数组，均值为 0 ，标准差为 1
15. ``eye(n)`` — n x n 单位矩阵
16. ``eye(m, n)`` — m x n 单位矩阵
17. ``linspace(start, stop, n)`` — 从 ``start`` 至 ``stop`` 的 ``n`` 个元素的线性向量
18. ``fill!(A, x)`` — 用 ``x`` 填充数组 ``A``

最后一个函数 ``fill!`` 直接修改了输入数组。按照惯例，修改输入的函数，函数名最后有感叹号。

内涵式语法
----------

内涵式语法类似于数学中的集合标记法： ::

    A = [ F(x,y,...) for x=rx, y=ry, ... ]

``F(x,y,...)`` 根据变量 ``x``, ``y`` 等来求值。这些变量的值可以由可迭代对象来指明，大多数情况下，都使用类似于 ``1:n`` 或 ``2:(n-1)`` 的范围，或指明为类似 ``[1.2, 3.4, 5.7]`` 的数组。它的结果是 N 维稠密数组。

下例计算在维度 1 上，当前元素及左右邻居元素的带权重平均数： ::

    julia> const x = rand(8)
    8-element Float64 Array:
     0.276455
     0.614847
     0.0601373
     0.896024
     0.646236
     0.143959
     0.0462343
     0.730987

    julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
    6-element Float64 Array:
     0.391572
     0.407786
     0.624605
     0.583114
     0.245097
     0.241854

注意：上例中， ``x`` 被声明为常量，因为对于非常量全局变量，Julia 的类型推断不怎么样。

可在内涵式表达式之前指明它的类型。如要避免在前例中声明 ``x`` 为常量，但仍要确保结果类型为 ``Float64`` ，应这样写： ::

    Float64[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]

使用花括号而非方括号，可以将它简写为 ``Any`` 类型的数组： ::

    julia> { i/2 for i = 1:3 }
    3-element Any Array:
     0.5
     1.0
     1.5

.. _man-array-indexing:

索引
----

索引 n 维数组 A 的通用语法为： ::

    X = A[I_1, I_2, ..., I_n]

其中 I\_k 可以是：

1. 标量
2. 满足 ``:``, ``a:b``, 或 ``a:b:c`` 格式的 ``Range``
3. 任意整数向量，包括空向量 ``[]``
4. 布尔值向量

结果 X 维度通常为 ``(length(I_1), length(I_2), ..., length(I_n))`` ，且 X 的索引 ``(i_1, i_2, ..., i_n)`` 处的值为 ``A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]`` 。缀在后面的标量索引的维度信息被舍弃。如，``A[I, 1]`` 的维度为 ``(length(I),)`` 。由布尔值向量索引的维度长度，是向量中 ``true`` 值的个数。

索引语法与调用 ``getindex`` 等价： ::

    X = getindex(A, I_1, I_2, ..., I_n)

例如： ::

    julia> x = reshape(1:16, 4, 4)
    4x4 Int64 Array
    1 5 9 13
    2 6 10 14
    3 7 11 15
    4 8 12 16

    julia> x[2:3, 2:end-1]
    2x2 Int64 Array
    6 10
    7 11

赋值
----

给 n 维数组 A 赋值的通用语法为： ::

    A[I_1, I_2, ..., I_n] = X

其中 I\_k 可能是：

1. 标量
2. 满足 ``:``, ``a:b``, 或 ``a:b:c`` 格式的 ``Range``
3. 任意整数向量，包括空向量 ``[]``
4. 布尔值向量

X 的维度为 ``(length(I_1), length(I_2), ..., length(I_n))`` ，且 A 在 ``(i_1, i_2, ..., i_n)`` 处的值被覆写为 ``X[I_1[i_1], I_2[i_2], ..., I_n[i_n]]`` 。

索引赋值语法等价于调用 ``setindex!`` ： ::

      A = setindex!(A, X, I_1, I_2, ..., I_n)

例如： ::

    julia> x = reshape(1:9, 3, 3)
    3x3 Int64 Array
    1 4 7
    2 5 8
    3 6 9

    julia> x[1:2, 2:3] = -1
    3x3 Int64 Array
    1 -1 -1
    2 -1 -1
    3 6 9

连接
----

使用下列语法，可在任意维度连接数组：

1. ``cat(dim, A...)`` — 沿维度 ``dim`` 连接输入的数组
2. ``vcat(A...)`` — 等价于 ``cat(1, A...)``
3. ``hcat(A...)`` — 等价于 ``cat(2, A...)``
4. ``hvcat(A...)``

连接运算符也可以用来连接数组：

1. ``[A B C ...]`` — 调用 ``hcat``
2. ``[A, B, C, ...]`` — 调用 ``vcat``
3. ``[A B; C D; ...]`` — 调用 ``hvcat``

向量化运算符和函数
------------------

数组支持下列运算符。在使用二元运算符时，如果两个输入都是向量，应使用带“点”版本的运算符；如果其中一个输入是标量，两种版本的运算符都可以使用。

1.  一元 — ``-``
2.  二元 — ``+``, ``-``, ``*``, ``.*``, ``/``, ``./``,
    ``\``, ``.\``, ``^``, ``.^``, ``div``, ``mod``
3.  比较 — ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``
4.  一元布尔值或位逻辑运算 — ``~``
5.  二元布尔值或位逻辑运算 — ``&``, ``|``, ``$``
6.  三角函数 — ``sin``, ``cos``, ``tan``, ``sinh``,
    ``cosh``, ``tanh``, ``asin``, ``acos``, ``atan``, ``atan2``,
    ``sec``, ``csc``, ``cot``, ``asec``, ``acsc``, ``acot``, ``sech``,
    ``csch``, ``coth``, ``asech``, ``acsch``, ``acoth``, ``sinc``,
    ``cosc``, ``hypot``
7.  对数函数 — ``log``, ``log2``, ``log10``, ``log1p``
8.  指数函数 — ``exp``, ``expm1``, ``exp2``, ``ldexp``
9.  舍入函数 — ``ceil``, ``floor``, ``trunc``, ``round``,
    ``ipart``, ``fpart``
10. 其它数学函数 — ``min``, ``max,`` ``abs``, ``pow``,
    ``sqrt``, ``cbrt``, ``erf``, ``erfc``, ``gamma``, ``lgamma``,
    ``real``, ``conj``, ``clamp``

广播式扩展
----------

有时要对不同维度的数组进行逐元素的二元运算，如将向量加到矩阵的每一列。低效的方法是，把向量复制成同维度的矩阵： ::

    julia> a = rand(2,1); A = rand(2,3);

    julia> repmat(a,1,3)+A
    2x3 Float64 Array:
     0.848333  1.66714  1.3262
     1.26743   1.77988  1.13859

维度很大时，效率会很低。Julia 提供了受 Matlab 启发的 ``bsxfun`` 函数，它将数组参数的维度进行扩展，使其匹配另一个数组的对应维度，且不需要额外内存，最后再应用输入的二元函数： ::

    julia> bsxfun(+, a, A)
    2x3 Float64 Array:
     0.848333  1.66714  1.3262
     1.26743   1.77988  1.13859

    julia> b = rand(1,2)
    1x2 Float64 Array:
     0.629799  0.754948

    julia> bsxfun(+, a, b)
    2x2 Float64 Array:
     1.31849  1.44364
     1.56107  1.68622

实现
----

Julia 的基础数组类型是抽象类型 ``AbstractArray{T,n}`` ，其中维度为 ``n`` ，元素类型为 ``T`` 。 ``AbstractVector`` 和 ``AbstractMatrix`` 分别是它 1 维 和 2 维的别名。

``Array{T,n}`` 类型是 ``AbstractArray`` 的特殊实例，它的元素以列序为主序存储。 ``Vector`` 和 ``Matrix`` 是分别是它 1 维 和 2 维的别名。

``SubArray`` 是 ``AbstractArray`` 的特殊实例，它通过引用而不是复制来进行索引。使用 ``sub`` 函数来构造 ``SubArray`` ，它的调用方式与 ``getindex`` 相同（使用数组和一组索引参数）。 ``sub`` 的结果与 ``getindex`` 的结果类似，但它的数据仍留在原地。 ``sub`` 在 ``SubArray`` 对象中保存输入的索引向量，这个向量将被用来间接索引原数组。

``StridedVector`` 和 ``StridedMatrix`` 是为了方便而定义的别名。通过给他们传递 ``Array`` 或 ``SubArray`` 对象，可以使 Julia 大范围调用 BLAS 和 LAPACK 函数，提高索引和申请内存的效率。

下面的例子计算大数组中的一个小块儿的 QR 分解，无需构造临时变量，直接调用合适的 LAPACK 函数：

.. code-block:: jlcon

    julia> a = rand(10,10)
    10x10 Float64 Array:
     0.763921  0.884854   0.818783   0.519682   …  0.860332  0.882295   0.420202
     0.190079  0.235315   0.0669517  0.020172      0.902405  0.0024219  0.24984
     0.823817  0.0285394  0.390379   0.202234      0.516727  0.247442   0.308572
     0.566851  0.622764   0.0683611  0.372167      0.280587  0.227102   0.145647
     0.151173  0.179177   0.0510514  0.615746      0.322073  0.245435   0.976068
     0.534307  0.493124   0.796481   0.0314695  …  0.843201  0.53461    0.910584
     0.885078  0.891022   0.691548   0.547         0.727538  0.0218296  0.174351
     0.123628  0.833214   0.0224507  0.806369      0.80163   0.457005   0.226993
     0.362621  0.389317   0.702764   0.385856      0.155392  0.497805   0.430512
     0.504046  0.532631   0.477461   0.225632      0.919701  0.0453513  0.505329

    julia> b = sub(a, 2:2:8,2:2:4)
    4x2 SubArray of 10x10 Float64 Array:
     0.235315  0.020172
     0.622764  0.372167
     0.493124  0.0314695
     0.833214  0.806369

    julia> (q,r) = qr(b);

    julia> q
    4x2 Float64 Array:
     -0.200268   0.331205
     -0.530012   0.107555
     -0.41968    0.720129
     -0.709119  -0.600124

    julia> r
    2x2 Float64 Array:
     -1.175  -0.786311
      0.0    -0.414549


**********
 矩阵分解
**********

`矩阵分解 <http://zh.wikipedia.org/wiki/矩阵分解>`_ 是将一个矩阵分
解为数个矩阵的乘积, 是线性代数中的一个核心概念.

下面的表格总结了在 Julia 中实现的几种矩阵分解方式. 具体的函数可以参考标准库文档
的 :ref:`stdlib-linalq` 章节.

=================== ==========================================================================================
``Cholesky``        `Cholesky分解 <http://en.wikipedia.org/wiki/Cholesky_decomposition>`_
``CheleskyPivoted`` `主元 <http://en.wikipedia.org/wiki/Pivot_element>`_ Cholesky 分解
``LU``              `LU分解 <http://en.wikipedia.org/wiki/LU_decomposition>`_
``QRPivoted``       主元 `QR分解 <http://en.wikipedia.org/wiki/QR_decomposition>`_
``Hessenberg``      `Hessenberg分解 <http://mathworld.wolfram.com/HessenbergDecomposition.html>`_
``Eigen``           `特征分解 <http://en.wikipedia.org/wiki/Eigendecomposition_(matrix)>`_
``SVD``             `奇异值分解 <http://en.wikipedia.org/wiki/Singular_value_decomposition>`_
``GeneralizedSVD``  `广义奇异值分解 <http://en.wikipedia.org/wiki/Generalized_singular_value_decomposition>`_
=================== ==========================================================================================


特殊矩阵
--------

线性代数中经常碰到带有对称性的特殊矩阵, 这些矩阵经常和矩阵分解联系到一起.
Julia 内置了非常丰富的特殊矩阵类型, 可以快速地对特殊矩阵进行特定的操作.

下面的表格总结了 Julia 中的特种矩阵类型, 其中也包含了 LAPACK 中的一些已经优化
过的操作方法.

+--------------------+-----------------------------------------------------------------------------+
| ``Hermitian``      | `埃尔米特矩阵 <http://en.wikipedia.org/wiki/Hermitian_matrix>`_             |
+--------------------+-----------------------------------------------------------------------------+
| ``Triangular``     | 上/下 `三角矩阵 <http://en.wikipedia.org/wiki/Triangular_matrix>`_          |
+--------------------+-----------------------------------------------------------------------------+
| ``Tridiagonal``    | `三对角矩阵 <http://en.wikipedia.org/wiki/Tridiagonal_matrix>`_             |
+--------------------+-----------------------------------------------------------------------------+
| ``SymTridiagonal`` | 对称三对角矩                                                                |
+--------------------+-----------------------------------------------------------------------------+
| ``Bidiagonal``     | 上/下 `bidiagonal matrix <http://en.wikipedia.org/wiki/Bidiagonal_matrix>`_ |
+--------------------+-----------------------------------------------------------------------------+
| ``Diagnoal``       | `对角矩阵 <http://en.wikipedia.org/wiki/Diagonal_matrix>`_                  |
+--------------------+-----------------------------------------------------------------------------+

基本运算
--------

+--------------------+-------+-------+-------+------------------+-------------------------------------+
| 矩阵类型           | ``+`` | ``-`` | ``*`` | ``\``            |  其它已优化的函数                   |
+====================+=======+=======+=======+==================+=====================================+
| ``Hermitian``      |       |       |       | XY               | ``inv``, ``sqrtm``, ``expm``        |
+--------------------+-------+-------+-------+------------------+-------------------------------------+
| ``Triangular``     |       | XY    | XY    | ``inv``, ``det`` |                                     |
+--------------------+-------+-------+-------+------------------+-------------------------------------+
| ``SymTridiagonal`` | X     | X     | XZ    | XY               | ``eigmax/min``                      |
+--------------------+-------+-------+-------+------------------+-------------------------------------+
| ``Tridiagonal``    | X     | X     | XZ    | XY               |                                     |
+--------------------+-------+-------+-------+------------------+-------------------------------------+
| ``Bidiagonal``     | X     | X     | XZ    | XY               |                                     |
+--------------------+-------+-------+-------+------------------+-------------------------------------+
| ``Diagnoal``       | X     | X     | XY    | XY               | ``inv``, ``det``, ``logdet``, ``/`` |
+--------------------+-------+-------+-------+------------------+-------------------------------------+

说明:

+---+---------------------+
| X | 对矩阵-矩阵运算优化 |
+---+---------------------+
| Y | 对矩阵-向量运算优化 |
+---+---------------------+
| Z | 对矩阵-纯量运算优化 |
+---+---------------------+

矩阵分解
--------

+--------------------+---------+-------------+-------------+---------+-------------+
| 矩阵类型           | 特征性  | 特征性      |             |         |             |
|                    +---------+-------------+-------------+---------+-------------+
|                    | ``eig`` | ``eigvals`` | ``eigvecs`` | ``svd`` | ``svdvals`` |
+====================+=========+=============+=============+=========+=============+
| ``Hermitian``      |         | ABC         |             |         |             |
+--------------------+---------+-------------+-------------+---------+-------------+
| ``Triangular``     |         |             |             |         |             |
+--------------------+---------+-------------+-------------+---------+-------------+
| ``SymTridiagonal`` | A       | ABC         | AD          |         |             |
+--------------------+---------+-------------+-------------+---------+-------------+
| ``Tridiagonal``    |         |             |             |         |             |
+--------------------+---------+-------------+-------------+---------+-------------+
| ``Bidiagonal``     |         |             |             | A       | A           |
+--------------------+---------+-------------+-------------+---------+-------------+
| ``Diagnoal``       |         | A           |             |         |             |
+--------------------+---------+-------------+-------------+---------+-------------+

说明:

+---+--------------------------------------------------------+------------------------+
| A | 对寻找特征值和/或特征向量优化                          | 例如 ``eigvals(M)``    |
+---+--------------------------------------------------------+------------------------+
| B | 对寻找 ``il``:sup:`th` 直到 ``ih``:sup:`th` 特征值优化 | ``eigvals(M, il, ih``  |
+---+--------------------------------------------------------+------------------------+
| C | 对寻找在 [``vl``, ``vh``]  之间的特征指优化            | ``eigvals(M, vl, vh)`` |
+---+--------------------------------------------------------+------------------------+
| D | 对寻找特征值 ``x=[x1, x2,...]`` 对应的特征向量优化     | ``eigvecs(M, x)``      |
+---+--------------------------------------------------------+------------------------+


**********
 稀疏矩阵
**********

`稀疏矩阵 <http://zh.wikipedia.org/zh-cn/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5>`_ 是其元素大部分为 0 的矩阵。

列压缩（CSC）存储
-----------------

Julia 中，稀疏矩阵使用 `列压缩（CSC）格式 <http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29>`_ 。Julia 稀疏矩阵的类型为 ``SparseMatrixCSC{Tv,Ti}`` ，其中 ``Tv`` 是非零元素的类型， ``Ti`` 是整数类型，存储列指针和行索引： ::

    type SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
        m::Int                  # Number of rows
        n::Int                  # Number of columns
        colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)
        rowval::Vector{Ti}      # Row values of nonzeros
        nzval::Vector{Tv}       # Nonzero values
    end

列压缩存储便于按列简单快速地存取稀疏矩阵的元素，但按行存取则较慢。把非零值插入 CSC 结构等运算，都比较慢，这是因为稀疏矩阵中，在所插入元素后面的元素，都要逐一移位。

构造稀疏矩阵
------------

稠密矩阵有 ``zeros`` 和 ``eye`` 函数，稀疏矩阵对应的函数，在函数名前加 ``sp`` 前缀即可： ::

    julia> spzeros(3,5)
    3x5 sparse matrix with 0 nonzeros:

    julia> speye(3,5)
    3x5 sparse matrix with 3 nonzeros:
        [1, 1]  =  1.0
        [2, 2]  =  1.0
        [3, 3]  =  1.0

``sparse`` 函数是比较常用的构造稀疏矩阵的方法。它输入行索引 ``I`` ，列索引向量 ``J`` ，以及非零值向量 ``V`` 。 ``sparse(I,J,V)`` 构造一个满足 ``S[I[k], J[k]] = V[k]`` 的稀疏矩阵： ::

    julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

    julia> sparse(I,J,V)
    5x18 sparse matrix with 4 nonzeros:
         [1 ,  4]  =  1
         [4 ,  7]  =  2
         [5 ,  9]  =  3
         [3 , 18]  =  -5

与 ``sparse`` 相反的函数为 ``findn`` ，它返回构造稀疏矩阵时的输入： ::

    julia> findn(S)
    ([1, 4, 5, 3],[4, 7, 9, 18])

    julia> findn_nzs(S)
    ([1, 4, 5, 3],[4, 7, 9, 18],[1, 2, 3, -5])

另一个构造稀疏矩阵的方法是，使用 ``sparse`` 函数将稠密矩阵转换为稀疏矩阵： ::

    julia> sparse(eye(5))
    5x5 sparse matrix with 5 nonzeros:
        [1, 1]  =  1.0
        [2, 2]  =  1.0
        [3, 3]  =  1.0
        [4, 4]  =  1.0
        [5, 5]  =  1.0

可以使用 ``dense`` 或 ``full`` 函数做逆操作。 ``issparse`` 函数可用来检查矩阵是否稀疏： ::

    julia> issparse(speye(5))
    true

稀疏矩阵操作
------------

稠密矩阵的算术运算也可以用在稀疏矩阵上。对稀疏矩阵进行赋值运算，是比较费资源的。大多数情况下，建议使用 ``find_nzs`` 函数把稀疏矩阵转换为 ``(I,J,V)`` 格式，在非零数或者稠密向量 ``(I,J,V)`` 的结构上做运算，最后再重构回稀疏矩阵。

稠密矩阵和稀疏矩阵函数对应关系
------------------------------

接下来的表格列出了关于稀疏矩阵的函数, 及其相应的稠密矩阵的函数.一般来讲, 产生稀疏矩阵的函数和对应的稠密矩阵函数的差别在于是否以 ``sp`` 打头, 或者参数列表中带有密度参数 ``d``, 即, 每个矩阵的元素是非零的概率为 ``d``.

具体的细节可以参考标准库文档的 :ref:`stdlib-sparse` 章节.

+------------------+----------------------------+-----------------------------+
| 稀疏矩阵         | 稠密矩阵                   | 说明                        |
+==================+============================+=============================+
| ``spzeos(m, n)`` | ``zeros(m, n)``            | 建立一个 *m* 行 *n*         |
|                  |                            | 列的零矩阵.                 |
+------------------+----------------------------+-----------------------------+
| ``spons(S)``     | ``ones(m, n)``             | 建立一个矩阵,               |
|                  |                            | 全部填充一.                 |
|                  |                            | 不同于版本, ``spones``      |
|                  |                            | 与 *S*                      |
|                  |                            | 有着相同的稀疏              |
|                  |                            | 模式.                       |
+------------------+----------------------------+-----------------------------+
| ``speye(n)``     | ``eye(n)``                 | 建立一个 *n* 行 *n*         |
|                  |                            | 列的单位矩阵.               |
+------------------+----------------------------+-----------------------------+
| ``dense(S)``     | ``sparse(A)``              | 转换稀疏矩阵和稠密          |
| ``full(S)``      |                            | 矩阵.                       |
+------------------+----------------------------+-----------------------------+
| ``sprand(m, n,   | ``rand(m, n)``             | 建立一个 *m* 行 *n*         |
| d)``             |                            | 列的随机矩阵                |
|                  |                            | (密度为 *d* ),              |
|                  |                            | 非零元素为 [0, 1]           |
|                  |                            | 上的均匀分布.               |
+------------------+----------------------------+-----------------------------+
| ``sprandn(m, n,  | ``randn(m, n)``            | 建立一个 *m* 行 *n*         |
| d)``             |                            | 列的随机矩阵                |
|                  |                            | (密度为 *d* ), 非零元       |
|                  |                            | 素为标准正态(高斯)          |
|                  |                            | 分布.                       |
+------------------+----------------------------+-----------------------------+
| ``sprandn(m, n,  | ``randn(m, n, X)``         | 建立一个 *m* 行 *n*         |
| d, X)``          |                            | 列的 随机矩阵,              |
|                  |                            | 非零元素的分布与            |
|                  |                            | *X* 相同 (依赖              |
|                  |                            | ``Distributions`` 包).      |
+------------------+----------------------------+-----------------------------+
| ``spandbool(m,   | ``randbool(m, n)``         | 建立一个 *m* 行 *n*         |
| n, d)``          |                            | 列的 随机矩阵               |
|                  |                            | (密度为 *d* ), 非零         |
|                  |                            | ``Bool``                    |
|                  |                            | 元素出现的概率为            |
|                  |                            | *d* (对于 ``randbool``,     |
|                  |                            | *d* = 0.5).                 |
+------------------+----------------------------+-----------------------------+
